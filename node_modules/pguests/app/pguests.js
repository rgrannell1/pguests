
"use strict"





const fs = require('fs')




const constants = {
	paths: {
		tcp:  '/proc/net/tcp',
		tcp6: '/proc/net/tcp6'
	}
}





const standariseIpAddress = ip => {

	const addressParts = ip.split(':')

	return {

		ip: addressParts[0]
			.match(/.{1,2}/g)
			.reverse( )
			.map(byte => parseInt(byte, 16))
			.join('.'),

		port: parseInt(addressParts[1], 16)
	}

}



const parseProcTcp = content => {

	const whitespace  = /\s+/g
	const isTruthy    = val => {
		return !!val === true
	}

	const lines       = content.split('\n').filter(isTruthy)
	const headers     = lines[0].split(whitespace).filter(isTruthy)

	const connections = lines.slice(1)

	return connections
		.map(connection => connection.split(whitespace).filter(isTruthy))
		.map(part => {

			var partObj = { }

			headers.forEach((header, ith) => {
				partObj[header] = part[ith]
			})

			partObj.local_address = standariseIpAddress(partObj.local_address)
			partObj.rem_address   = standariseIpAddress(partObj.rem_address)

			return partObj

		})

}





const pguests = ( ) => {

	const encountered = { }

	fs.watchFile(constants.paths.tcp, (current, last) => {

		fs.readFile(constants.paths.tcp, 'ascii', (err, contents) => {

			parseProcTcp(contents).map(socket => {

				var ip   = socket.rem_address.ip
				var port = socket.rem_address.port

				if (encountered.hasOwnProperty(ip)) {

					if (encountered[ip].ports.indexOf(port) === -1) {
						encountered[ip].ports.push(port)
					}

				} else {

					encountered[ip] = {
						ports: [port]
					}

				}

			})

			console.log( encountered )

		})

	})


}





module.exports = pguests
