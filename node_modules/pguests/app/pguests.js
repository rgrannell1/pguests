
"use strict"





const fs     = require('fs')
const events = require('events')




const constants = {
	paths: {
		tcp:  '/proc/net/tcp',
		tcp6: '/proc/net/tcp6'
	},
	tcpStates: [

		'TCP_ESTABLISHED',
		'TCP_SYN_SENT',
		'TCP_SYN_RECV',
		'TCP_FIN_WAIT1',
		'TCP_FIN_WAIT2',
		'TCP_TIME_WAIT',
		'TCP_CLOSE',
		'TCP_CLOSE_WAIT',
		'TCP_LAST_ACK',
		'TCP_LISTEN',
		'TCP_CLOSING',
		'TCP_MAX_STATES'

	]
}





const standariseIpAddress = ip => {

	const addressParts = ip.split(':')

	return {

		ip: addressParts[0]
			.match(/.{1,2}/g)
			.reverse( )
			.map(byte => parseInt(byte, 16))
			.join('.'),

		port: parseInt(addressParts[1], 16)
	}

}





const parseProcTcp = content => {

	const whitespace  = /\s+/g
	const isTruthy    = val => {
		return !!val === true
	}

	const lines       = content.split('\n').filter(isTruthy)
	const headers     = lines[0].split(whitespace).filter(isTruthy)

	const connections = lines.slice(1)

	return connections
		.map(connection => connection.split(whitespace).filter(isTruthy))
		.map(part => {

			var partObj = { }

			headers.forEach((header, ith) => {
				partObj[header] = part[ith]
			})

			return {
				localAddress:  standariseIpAddress(partObj.local_address),
				remoteAddress: standariseIpAddress(partObj.rem_address),
				tcpState:      constants.tcpStates[parseInt(partObj.st, 16)]
			}

		})

}





const pguests = ( ) => {

	const encountered  = [ ]
	const eventEmitter = new events.EventEmitter( )

	fs.watchFile(constants.paths.tcp, (current, last) => {

		fs.readFile(constants.paths.tcp, 'ascii', (err, contents) => {

			parseProcTcp(contents).map(socket => {
				eventEmitter.emit('socket', socket)
			})

		})

	})

	return eventEmitter

}





module.exports = pguests
