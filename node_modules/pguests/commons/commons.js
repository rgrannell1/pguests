
"use strict"





const commons = {
	async: { },
	sort:  { }
}





commons.padString = (num, str) => {

	for (var ith = str.length; ith < num; ++ith) {
		str += ' '
	}

	return str

}

commons.maxByKeys = (fn, keys, objs) => {

	return objs.map(obj => {

		var out = { }

		keys.forEach(key => {
			out[key] = Math.max( out[key], fn(obj[key]) )
		})

		return out

	})

}





commons.async.map = function (fn, data, callback, acc) {

	acc = acc || [ ]

	if (data.length === 0) {
		callback(acc)
	} else {

		fn(data[0], function ( ) {

			commons.async.map(
				fn, data.slice(1), callback,
				acc.concat( [Array.prototype.slice.call(arguments)] ))

		})

	}

}





commons.sort.byPort = (port0, port1) => {

}

commons.sort.byIp = (ipData0, ipData1) => {

	/*
		the algorithm is partially taken from user 'Dan' on StackOverflow;
		partitions ipv4 / ipv6 addresses.
	*/

	var bits = [ipData0, ipData1].map(ipData => {

		const ipSpecifics = ipData.ipVersion === 'ipv4'
			? {separator: '.', converter: 256}
			: {separator: ':', converter: 65536}

		// convert the IP
		const sum = ipData.ip.split(ipSpecifics.separator)
			.reverse( )
			.map((part, ith) => {
				return parseInt(part, 10) * Math.pow(ipSpecifics.converter, (ith + 1))
			})
			.reduce((acc, num) => {
				return acc + num
			})

		// separate ipv6 addresses by adding the
		// largest possible ipv4 size to ip.

		return ipData.ipVersion === 'ipv4' ? sum : sum + 1099511627520 + 1

	})

	return bits[0] - bits[1]

}



module.exports = commons
