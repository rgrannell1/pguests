
"use strict"




const ipAddress = require('ip-address')





const commons = {
	async:   { },
	sort:    { },
	deparse: { }
}





commons.padString = (num, str) => {

	for (var ith = str.length; ith < num; ++ith) {
		str += ' '
	}

	return str

}

commons.maxByKeys = (fn, keys, objs) => {

	return objs.map(obj => {

		var out = { }

		keys.forEach(key => {
			out[key] = Math.max( out[key], fn(obj[key]) )
		})

		return out

	})

}





commons.async.map = (fn, data, callback, acc) => {

	acc = acc || [ ]

	if (data.length === 0) {
		callback(acc)
	} else {

		fn(data[0], function ( ) {

			commons.async.map(
				fn, data.slice(1), callback,
				acc.concat( [Array.prototype.slice.call(arguments)] ))

		})

	}

}

commons.async.pmap = (fn, data, callback) => {

	const acc = [ ]

	acc.watchPush = data => {

		acc.push(data)

		if (acc.length === data.length) {
			callback(acc)
		}

	}

	data.forEach(datum => {

		fn(datum, function ( ) {
			acc.watchPush(Array.prototype.slice.call(arguments))
		})

	})

}





commons.sort.byPort = (port0, port1) => {

}

/*
	the algorithm is partially taken from user 'Dan' on StackOverflow;
	partitions ipv4 / ipv6 addresses.
*/

commons.sort.byIp = (ipData0, ipData1) => {

	var ipSize = [ipData0, ipData1].map(ipData => {

		const ipSpecifics = ipData.ipVersion === 'ipv4'
			? {separator: '.', converter: 256}
			: {separator: ':', converter: 65536}

		// convert the IP
		const sum = ipData.ip.split(ipSpecifics.separator)
			.reverse( )
			.map((part, ith) => {
				return parseInt(part, 10) * Math.pow(ipSpecifics.converter, (ith + 1))
			})
			.reduce((acc, num) => {
				return acc + num
			})

		// separate ipv6 addresses by adding the
		// largest possible ipv4 size to ip.

		return ipData.ipVersion === 'ipv4' ? sum : sum + 1099511627520 + 1

	})

	return ipSize[0] - ipSize[1]

}




commons.deparse.ipv6 = ip => {
	return new ipAddress.Address6(ip).correctForm( )
}



module.exports = commons
