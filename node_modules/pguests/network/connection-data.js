
"use strict"





const fs           = require('fs')
const events       = require('events')

const constants    = require('pguests/commons/constants')
const commons      = require('pguests/commons/commons')
const readProcFile = require('pguests/fs/read-proc-file')
const parser       = require('pguests/commons/parser')
const findIpMetadata = require('pguests/network/find-ip-metadata')




const addPacketMetadata = (socket, callback) => {

	const remoteAddress = socket.rem_address || socket.remote_address

	findIpMetadata(remoteAddress, (err, hostname, service) => {

		if (hostname) {
			socket.metadata.hostname = hostname
		}

		if (service) {
			socket.metadata.service = service
		}

		socket.timestamp = new Date( )

		callback(socket)

	})

}





const emitNewSockets = (eventEmitter, socket, uids) => {

	if (uids.indexOf(socket.uid) === -1) {

		uids.push(socket.uid)

		addPacketMetadata(socket, socket => {
			eventEmitter.emit(constants.events.socket, socket)
		})

	}

}





const connectionData = ( ) => {

	const uids         = {
		[constants.protocols.ipv4]: [ ],
		[constants.protocols.ipv6]: [ ]
	}

	const eventEmitter = new events.EventEmitter( )
	const sources      = [

		{
			fpath:         constants.paths.tcp4,
			ipVersion: constants.protocols.ipv4,
			protocolLabel: 'TCP'
		},
		{
			fpath:         constants.paths.tcp6,
			ipVersion: constants.protocols.ipv6,
			protocolLabel: 'TCP'
		},

		{
			fpath:         constants.paths.udp4,
			ipVersion: constants.protocols.ipv4,
			protocolLabel: 'UDP'
		},
		{
			fpath:         constants.paths.udp6,
			ipVersion:     constants.protocols.ipv6,
			protocolLabel: 'UDP'
		}

	]

	sources.forEach(params => {

		// each watched file needs to be closed on shutdown.
		readProcFile(params.fpath, (err, contents) => {

			if (err) {
				process.stderr.write(`${err.message}\n`)
			} else {

				parser.parseProcFile(params.protocolLabel, params.ipVersion, contents).map(socket => {
					emitNewSockets(eventEmitter, socket, uids[params.ipVersion])
				})

			}

		})

	})

	eventEmitter.close = ( ) => {

		sources.forEach(source => {
			fs.unwatchFile(source.fpath)
		})

	}

	return eventEmitter

}





module.exports = connectionData
