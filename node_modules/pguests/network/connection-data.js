
"use strict"





const fs           = require('fs')
const events       = require('events')

const constants    = require('pguests/commons/constants')
const commons      = require('pguests/commons/commons')
const readProcFile = require('pguests/fs/read-proc-file')
const parser       = require('pguests/commons/parser')





const emitNewSockets = (eventEmitter, socket, uids) => {

	if (uids.indexOf(socket.uid) === -1) {

		uids.push(socket.uid)
		eventEmitter.emit(constants.events.socket, socket)

	}

}





const connectionData = ( ) => {

	const uids         = {
		[constants.protocols.ipv4]: [ ],
		[constants.protocols.ipv6]: [ ]
	}

	const eventEmitter = new events.EventEmitter( )
	const sources      = [

		{fpath: constants.paths.tcp4, ipVersion: constants.protocols.ipv4, protocolLabel: 'TCP'},
		{fpath: constants.paths.tcp6, ipVersion: constants.protocols.ipv6, protocolLabel: 'TCP'},

		{fpath: constants.paths.udp4, ipVersion: constants.protocols.ipv4, protocolLabel: 'UDP'},
		{fpath: constants.paths.udp6, ipVersion: constants.protocols.ipv6, protocolLabel: 'UDP'}

	]

	sources.forEach(params => {

		// each watched file needs to be closed on shutdown.
		readProcFile(params.fpath, (err, contents) => {

			if (err) {
				process.stderr.write(`${err.message}\n`)
			} else {

				parser.parseProcFile(params.protocolLabel, params.ipVersion, contents).map(socket => {
					emitNewSockets(eventEmitter, socket, uids[params.ipVersion])
				})

			}

		})

	})

	eventEmitter.close = ( ) => {

		sources.forEach(source => {
			fs.unwatchFile(source.fpath)
		})

	}

	return eventEmitter

}





module.exports = connectionData
