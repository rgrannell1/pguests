
"use strict"





const constants      = require('pguests/commons/constants')
const commons        = require('pguests/commons/commons')
const findIpMetadata = require('pguests/network/find-ip-metadata')





const reporters = { }





const groupOnRemoteIpPorts = sockets => {

	var aggregate = [ ]

	for (var ith = 0; ith < sockets.length; ++ith) {

		var socket     = sockets[ith]
		var matchFound = false

		for (var jth = 0; jth < aggregate.length; ++jth) {

			if (socket.remote.ip === aggregate[jth].ip) {

				matchFound = true

				var ports  = aggregate[jth].ports
				ports      = (ports[socket.remote.port] || [ ]).concat(socket.local)

				break

			}

		}

		if (!matchFound) {

			aggregate.push({

				ip:        socket.remote.ip,
				ipVersion: socket.remote.ipVersion,
				ports:     {
					[socket.remote.port]: [socket.local]
				},
				metadata:  socket.metadata

			})

		}


	}

	return aggregate

}





const showRemoteServer = (maxLengths, err, ipData, hostname, service) => {

	var messsage = ''
	var margin   = '   '

	if (service) {
		messsage += margin + commons.padString(5 + margin.length, service)
	} else {
		messsage += margin + commons.padString(5 + margin.length, ipData.port)
	}


	// remove protocol hard-coding.
	messsage += margin + ipData.metadata.protocol + margin +
		(hostname ? hostname : constants.messages.unknownHost) + '\n'

	console.log(messsage)

}





const showRemoteIpProfile = (maxLengths, serverData) => {

	if (serverData) {

		const ipData = serverData[0][1]
		console.log(ipData.ip)

	}

	serverData.forEach(serverDatum => {
		showRemoteServer.bind({}, maxLengths).apply({ }, serverDatum)
	})

}









reporters.reportRates = received =>{

	var sockets = received.map(socket => {

		var reformatted = {
			local:     socket.local_address,
			remote:    socket.remote_address || socket.rem_address,
			metadata:  socket.metadata
		}

		return reformatted

	})

	process.stdout.write(constants.ansiiEscapes.clearScreen)

	var remoteIps    = groupOnRemoteIpPorts(sockets)
	const maxLengths = commons.maxByKeys(val => val.length, ['ip'], remoteIps)

	// nested async maps!
	// factor out this code into shared module.
	commons.async.map(
		(remoteIp, remoteIpCallback) => {

			// for each remote ip, check each port's hostname, print information.
			const remoteServerData = Object.keys(remoteIp.ports).sort( ).map(port => {

				return {
					port,
					ip:        remoteIp.ip,
					ipVersion: remoteIp.ipVersion,
					metadata:  remoteIp.metadata
				}

			})

			// check who owns each port.
			commons.async.map(
				(serverDatum, callback) => {

					findIpMetadata(serverDatum, (err, hostname, service) => {
						callback(err, serverDatum, hostname, service)
					})

				},
				remoteServerData,
				serverData => {

					showRemoteIpProfile(maxLengths, serverData)
					remoteIpCallback( )

				}
			)

		},
		// sort the IPs by IP address (no eq. case).
		remoteIps.sort((rem0, rem1) => {
			return commons.sort.byIp(rem0.ip, rem1.ip)
		}),

		( ) => {
			// noop for the moment.
		}
	)

}





module.exports = reporters
