
"use strict"





const constants      = require('pguests/commons/constants')
const commons        = require('pguests/commons/commons')

const reporters = { }





const groupOnRemoteIpPorts = sockets => {

	var aggregate = [ ]

	for (var ith = 0; ith < sockets.length; ++ith) {

		var socket     = sockets[ith]
		var matchFound = false

		for (var jth = 0; jth < aggregate.length; ++jth) {

			if (socket.remote.ip === aggregate[jth].ip) {

				matchFound = true

				var ports  = aggregate[jth].ports
				ports      = (ports[socket.remote.port] || [ ]).concat(socket.local)

				break

			}

		}

		if (!matchFound) {

			aggregate.push({

				ip:        socket.remote.ip,
				ipVersion: socket.remote.ipVersion,
				ports:     {
					[socket.remote.port]: [socket.local]
				},
				metadata:  socket.metadata

			})

		}


	}

	return aggregate

}





const showRemoteServer = (maxLengths, remoteIp) => {

	const margin   = '   '

	const service  = remoteIp.service
	const hostname = remoteIp.hostname

	console.log([

			service
				? margin + commons.padString(5 + margin.length, service)
				: margin + commons.padString(5 + margin.length, remoteIp.port),

			margin + remoteIp.protocol + margin +
				(hostname ? hostname : constants.messages.unknownHost)

		]
		.join('')

	)

}





const showRemoteIpProfile = (maxLengths, serverData) => {

	if (serverData) {

		const ipData = serverData[0]

		if (ipData.ipVersion === 'ipv6') {
			console.log(commons.deparse.ipv6(ipData.ip))
		} else {
			console.log(ipData.ip)
		}

	}

	serverData.forEach(serverDatum => {
		showRemoteServer(maxLengths, serverDatum)
	})

}









reporters.reportRates = (args, sockets, callback) => {

	process.stdout.write(constants.ansiiEscapes.clearScreen)

	var remoteIps    = groupOnRemoteIpPorts(sockets)

	const maxLengths = commons.maxByKeys(val => val.length, ['ip'], remoteIps)

	remoteIps.sort(commons.sort.byIp).forEach(remoteIp => {

		// for each remote ip, check each port's hostname, print information.
		const remoteServerData = Object.keys(remoteIp.ports).sort( ).map(port => {

			return {
				port,
				ip:        remoteIp.ip,
				ipVersion: remoteIp.ipVersion,
				metadata:  remoteIp.metadata,
				ipVersion: 'tcp'
			}

		})

		showRemoteIpProfile(maxLengths, remoteServerData)

	})

	callback( )

}





module.exports = reporters
