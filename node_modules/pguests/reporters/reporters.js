
"use strict"





const constants      = require('pguests/commons/constants')
const commons        = require('pguests/commons/commons')
const findIpMetadata = require('pguests/network/find-ip-metadata')





const reporters = { }





const groupOnRemoteIpPorts = sockets => {

	var aggregate = [ ]

	for (var ith = 0; ith < sockets.length; ++ith) {

		var socket     = sockets[ith]
		var matchFound = false

		for (var jth = 0; jth < aggregate.length; ++jth) {

			if (socket.remote.ip === aggregate[jth].ip) {

				matchFound = true

				var ports  = aggregate[jth].ports
				ports      = (ports[socket.remote.port] || [ ]).concat(socket.local)

				break

			}

		}

		if (!matchFound) {

			aggregate.push({

				ip:        socket.remote.ip,
				ipVersion: socket.remote.ipVersion,
				ports:     {
					[socket.remote.port]: [socket.local]
				}

			})

		}


	}

	return aggregate

}





const showRemoteServer = (maxLengths, err, ipData, hostname, service) => {

	var messsage = ''
	var margin   = '   '

	messsage += margin + commons.padString(5 + margin.length, ipData.port)
	messsage += margin + (hostname ? hostname : 'unknown-host')            + '\n'

	console.log(messsage)

}





const showRemoteIpProfile = (maxLengths, serverData) => {

	if (serverData) {

		const ipData = serverData[0][1]
		console.log(ipData.ip)

	}

	serverData.forEach(serverDatum => {
		showRemoteServer.bind({}, maxLengths).apply({ }, serverDatum)
	})

}









reporters.reportRates = received =>{

	// TODO refactor this garbage into multiple functions.

	var sockets = received.map(socket => {

		var reformatted = {
			local:     socket.local_address,
			remote:    socket.remote_address || socket.rem_address,
			metadata:  socket.metadata
		}

		return reformatted

	})

	// to clear the screen.
	process.stdout.write(constants.ansiiEscapes.clearScreen)

	var remoteIps    = groupOnRemoteIpPorts(sockets)
	const maxLengths = commons.maxByKeys(val => val.length, ['ip'], remoteIps)

	remoteIps.forEach(remoteIp => {

		const remoteServerData = Object.keys(remoteIp.ports).map(port => {
			return {port, ip: remoteIp.ip, ipVersion: remoteIp.ipVersion}
		})

		commons.async.map(
			(serverDatum, callback) => {

				findIpMetadata(serverDatum, (err, hostname, service) => {
					callback(err, serverDatum, hostname, service)
				})

			},
			remoteServerData,
			showRemoteIpProfile.bind({ }, maxLengths)
		)

	})

}





module.exports = reporters
